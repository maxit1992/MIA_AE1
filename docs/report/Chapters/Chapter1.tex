% Chapter 1

\chapter{Desarrollo} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 
\label{IntroGeneral}

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}
\newcommand{\grados}{$^{\circ}$}

%----------------------------------------------------------------------------------------

%\section{Introducción}

%----------------------------------------------------------------------------------------
\section{Introducción}

En el presente trabajo práctico, se desarrolla la implementación del algoritmo de Optimización por Enjambre de Partículas (PSO) en la búsqueda de una solución óptima a un problema de posicionamiento. El objetivo es poder evaluar la implementación e idoneidad del algoritmo y compararlo con otros métodos simples.

En el problema planteado se parte de una posición global conocida y se simula la pérdida de señal del dispositivo GPS y la presencia de mediciones de velocidad y ángulo de movimiento respecto al norte. El objetivo es poder continuar trazando una ubicación precisa e idónea del recorrido realizado, sin contar con las mediciones de posicionamiento. Esta situación es común en sistemas embebidos y puede ocurrir ya sea por pérdida de señal del GPS (entre las mas recurrentes: por un diseño incorrecto de la antena de recepción, por fallas en el software del dispositivo o bien perdida de línea de vista al cielo) o bien porque se desea reducir el consumo eléctrico y se hace un apagado temporal del GPS.

Como prueba de concepto, se realizó un recorrido por la ciudad de Rosario en auto y se utilizó un celular para hacer datalogging de los sensores junto con la información del GPS. Se probará si es posible realizar el seguimiento del vehículo sin utilizar la latitud y longitud del GPS.

Inicialmente se hará una simulación utilizando los datos raw de los sensores y se demostrará que el ruido inherente de los mismos genera un  recorrido muy alejado del real. A continuación se incluirá en la simulación optimización PSO para lograr ajustar las mediciones a valores óptimos que mejorarán el recorrido simulado. 

\section{Mapa}

Para poder realizar las simulaciones es necesario contar con utilidades que realicen gráficos y cálculos geográficos. Con este fin se implementó en Python la clase \textit{Map} con la siguientes características:
\begin{itemize}
    \item Utiliza la librería OpenCV y Matplotlib para poder graficar el mapa de la zona de interés y marcar sobre el mismo puntos rojos que representan posiciones (latitud y longitud) y trayectos (figura \ref{fig:map}). 
    \item Método de calibración para poder realizar la transformación entre latitudes y longitudes y píxeles en la imagen del mapa, de manera de poder trabajar indistintamente con cualquiera de los dos sistemas de referencia. Para poder realizar la calibración correcta, se tomaron 4 puntos de referencia conocidos y se entrenaron dos modelos de regresión lineal para realizar las transformaciones bidireccionales latitud/longitud $\Leftrightarrow$ pixeles verticales/horizontales.
    \item Soporta mapa de política con máscaras de probabilidad (figura \ref{fig:policy}) que asignan a cada pixel del mapa original un valor entre 0 y 1 según la posición sea más probable o menos. Así, las calles y avenidas tendrán un valor de 1, mientras que los centros de manzana, el río y zonas donde es imposible realizar un recorrido tienen valor 0. Entre ambos valores 1 y 0, la máscara asigna valores decrecientes para poder obtener una política que varía en forma suave.
    \item Algoritmo que permite obtener el punto final (latitud y longitud) luego de desplazarse X métros con un cierto ángulo Y respecto al norte desde una posición inicial conocida.
    \item Algoritmo Haversine para obtener la distancia en metros y el angulo respecto al norte del segmento sobre la superficie Terrestre que conecta dos puntos con posiciones conocidas.
\end{itemize}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.7\textwidth]{./Figures/map.png}
	\caption{Mapa de zona de interés (ciudad de Rosario).}
	\label{fig:map}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.7\textwidth]{./Figures/policy.jpg}
	\caption{Mapa de política con máscara de probabilidad.}
	\label{fig:policy}
\end{figure}

\section{Partícula}

Otra utilidad necesaria es la clase que modela el objeto que se desplaza por el mapa. Este objeto se implementó en Python en la clase \textit{Particle}, que posee las siguientes características:
\begin{itemize}
    \item Se inicializa con una posición inicial (latitud, longitud), una serie de tiempo de velocidades, una serie de tiempo de ángulos de movimiento respecto al norte y una instancia de la clase \textit{Map} donde se realizará el recorrido.
    \item Provee métodos para moverse un paso de tiempo, utilizando las series de tiempo provistas en la inicialización.
    \item Provee métodos para acumular distancia desplazada. Este método es útil para no ejecutar algoritmos en cada paso de tiempo (donde el desplazamiento puede haber sido 0 metros si el objeto se encontraba parado), sino luego de desplazarse determinada distancia.
    \item Provee métodos para evaluar una posición o un movimiento en base a la política cargada en la instancia de la clase \textit{Map}.
    \item Provee métodos para ejecutar el algoritmo PSO, en base a la posición actual, la mejor posición (medida con respecto a la política) hasta el momento de la partícula en cuestión, y la posición de la mejor partícula del enjambre.
\end{itemize}

\section{Datos}

TODO

\section{Política}

TODO

\section{Simulación}

\subsection{Datos crudos}

Inicialmente, y a fin de tener una base de comparación, se crea una única partícula con posición inicial conocida y los datos de movimiento (velocidad y ángulo) sin procesar tal cual se obtuvieron del datalogger. Posteriormente se ejecutó el método \textit{move} de la clase \textit{Particle} repetidas veces hasta ejecutar todos los pasos disponibles .En resumen, el algoritmo de evolución sería el siguiente:

ALGORITMO

\subsection{Partículas con series de tiempo con ruido}

A fin de mejorar el trayecto, se realizó una simulación con un enjambre de 500 partículas. Cada partícula se inicializó con la posición inicial ligeramente desplazada (dentro de un radio de 50 metros) y copias de las series de tiempo de velocidad y ángulo de movimiento con ruidos normales superpuestos. Luego se ejecutó el trayecto completo para todas las partículas y se evaluó la política acumulada durante cada trayecto. Finalmente se seleccionó la mejor partícula como aquella con mayor valor de política acumulada. En resumen, el algoritmo de evolución sería el siguiente:

ALGORITMO

\subsection{PSO}

Sobre el caso anterior se realizó una mejora consistente en ejecutar cada cierta longitud de desplazamiento (configurada inicialmente en 50 metros) una corrida de 50 épocas del algoritmo PSO, donde la partícula se mueve una porción en la dirección y velocidad de la inercia (paso de movimiento anterior), otra porción en la dirección de la mejor posición encontrada por dicha partícula y una porción en la dirección de la mejor partícula (evaluada según la política) del enjambre. En resumen, el algoritmo de evolución sería el siguiente:

ALGORITMO


\section{Resultados}

\subsection{Datos crudos}

Finalmente, se graficó el trayecto obtenido sobre el mapa, obteniendo la figura \ref{fig:journey_raw}. 

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/journey_raw.png}
	\caption{Trayecto partícula única con datos sin procesar.}
	\label{fig:journey_raw}
\end{figure}

Como se observa, el recorrido se aleja de posiciones válidas, pasando la mayor parte del mismo por encima del agua.

\subsection{Partículas con series de tiempo con ruido}

El trayecto obtenido para la mejor partícula se grafica en la figura \ref{fig:journey_noise}. Se observa que si bien existe una mejora respecto al trayecto obtenido con los datos sin procesar, aún existen segmentos donde el recorrido se aleja de posiciones válidas, en especial en la mitad del mismo. En el siguiente \href{https://drive.google.com/file/d/1715t2DZ9hEKqsWBAROogAUpSU2egc3Sw/view?usp=sharing}{link} se puede validar el paso a paso de la evolución del trayecto a lo largo de la ejecución del algoritmo para todo el enjambre.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/journey_noise.png}
	\caption{Trayecto mejor partícula en enjambre de 500 partículas con datos con ruido.}
	\label{fig:journey_noise}
\end{figure}
 
Para poder evaluar y comparar cuantitativamente este y el algoritmo siguiente, se realizaron dos gráficas de la evolución de la aptitud en función de los pasos de movimientos realizados. Este valor se calculo tanto en forma totalizada para las 500 partículas disponibles en la figura \ref{fig:fitness_noise_all_particle}, como para la mejor partícula en la figura \ref{fig:fitness_noise_max_particle}. En ambas figuras se puede ver y analizar con mayor detalle lo mencionado previamente, se observa un crecimiento sostenido inicial de la aptitud, zonas medias de estancamiento y una zona final de crecimiento leve. Más aún, tomando los valores finales, se obtuvieron un acumulado de aptitud de 23889, equivalente a un promedio de 82 por épocas total del enjambre o de 0.164 promedio por partícula por época (muy alejado del ideal de 1.0). Para la mejor partícula, y tomando los valores finales, se obtuvo un acumulado de 153, equivalente a aproximádamenete 0.5 por época promedio (también alejado del ideal).

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/fitness_noise_all_particle.png}
	\caption{Función de aptitud acumulada de todas las partículas}
	\label{fig:fitness_noise_all_particle}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/fitness_noise_max_particle.png}
	\caption{Función de aptitud para mejor partícula.}
	\label{fig:fitness_noise_max_particle}
\end{figure}

\subsection{PSO}

El trayecto obtenido para la mejor partícula se grafica en la figura \ref{fig:journey_pso}. Se observa una mejora notoria respecto a los métodos anteriores, ya que ahora la partícula se mantiene en posiciones válidas durante todo el trayecto. En el siguiente \href{https://drive.google.com/file/d/1wSDkcD2eM4zI_VGLMLFX8jCljR5nznkf/view?usp=sharing}{link} se puede validar el paso a paso de la evolución del trayecto a lo largo de la ejecución del algoritmo.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/journey_pso.png}
	\caption{Trayecto mejor partícula en enjambre de 500 partículas PSO.}
	\label{fig:journey_pso}
\end{figure}


\section{Conclusiones}
\label{sec:conclusions}


\section{Trabajo futuro}

